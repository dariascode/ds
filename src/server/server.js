const express = require('express');
const bodyParser = require('body-parser');
const fs = require('fs-extra');
const fsSync = require('fs');
const axios = require('axios');
const RaftNode = require('./raft');
const createLogger = require('../logger/logger');
const logger = createLogger({ type: 'crud' });
const store = require('./fileStore');
const path = require('path');

const configPath = process.argv[2];
if (!configPath) {
    console.error('‚ùå –£–∫–∞–∂–∏ –ø—É—Ç—å –∫ –∫–æ–Ω—Ñ–∏–≥—É: node server.js configs/nodeA/server1.json');
    process.exit(1);
}

const config = JSON.parse(fsSync.readFileSync(configPath, 'utf-8'));
const PORT = config.port;
const selfId = config.id;
const peers = config.peers || [];
const dataDir = config.dataDir;
const raft = new RaftNode(config);

const app = express();
const jsonParser = bodyParser.json();

let isShuttingDown = false;
let activeRequests = 0;

const crudStats = {
    create: 0,
    read: 0,
    delete: 0
};


app.use((req, res, next) => {
    if (isShuttingDown) {
        return res.status(503).send('‚õî –°–µ—Ä–≤–µ—Ä –≤—ã–∫–ª—é—á–∞–µ—Ç—Å—è');
    }
    activeRequests++;
    res.on('finish', () => {
        activeRequests--;
        if (isShuttingDown && activeRequests === 0) {
            logger.info(`[${selfId}] ‚úÖ –í—Å–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –∑–∞–≤–µ—Ä—à–µ–Ω—ã. –ó–∞–≤–µ—Ä—à–∞–µ–º –ø—Ä–æ—Ü–µ—Å—Å.`);
            process.exit(0);
        }
    });
    next();
});

app.get('/key/ping', (req, res) => {
    res.send('üü¢ –Ø –∂–∏–≤!');
});

app.get('/whoami', (req, res) => {
    res.json({
        id: selfId,
        port: PORT,
        state: raft.state,
        leader: raft.leaderId
    });
});

app.post('/internal/replicate', jsonParser, async (req, res) => {
    const { key, value } = req.body;
    try {
        await store.saveKeyValue(dataDir, key, value);
        crudStats.create++;
        logger.info(`[${selfId}] üìÑ –†–µ–ø–ª–∏–∫–∞—Ü–∏—è –∫–ª—é—á–∞ ${key}`);
        res.send({ status: 'ok' });
    } catch (err) {
        logger.error(`[${selfId}] ‚ùå –û—à–∏–±–∫–∞ —Ä–µ–ø–ª–∏–∫–∞—Ü–∏–∏: ${err.message}`);
        res.status(500).send({ status: 'error' });
    }
});

app.post('/internal/delete', jsonParser, async (req, res) => {
    const { key } = req.body;
    try {
        await store.deleteKeyValue(dataDir, key);
        crudStats.delete++;
        logger.info(`[${selfId}] üß® –†–µ–ø–ª–∏–∫–∞—Ü–∏—è —É–¥–∞–ª–µ–Ω–∏—è ${key}`);
        res.send({ status: 'ok' });
    } catch (err) {
        logger.error(`[${selfId}] ‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Ä–µ–ø–ª–∏–∫–∏: ${err.message}`);
        res.status(500).send({ status: 'error' });
    }
});

async function redirectIfNotLeader(req, res, next) {
    logger.info(`[${selfId}] üß≠ redirectIfNotLeader ‚Üí state: ${raft.state}, leaderId: ${raft.leaderId}`);

    if (raft.state === 'leader') {
        logger.info(`[${selfId}] ‚úÖ –Ø –ª–∏–¥–µ—Ä, –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º`);
        return next();
    }

    if (!raft.leaderId) {
        logger.warn(`[${selfId}] ‚ùå –ù–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –ª–∏–¥–µ—Ä–µ`);
        return res.status(503).send('‚ùå –ù–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –ª–∏–¥–µ—Ä–µ');
    }

    const selfUrl = `http://localhost:${PORT}`;
    if (raft.leaderId === selfUrl) {
        logger.warn(`[${selfId}] ‚ö†Ô∏è –Ø –¥—É–º–∞—é, —á—Ç–æ —è –Ω–µ –ª–∏–¥–µ—Ä, –Ω–æ leaderId —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ –º–µ–Ω—è`);
        return next();
    }

    try {
        const leaderBase = raft.leaderId.replace(/\/$/, '');
        const targetUrl = leaderBase + req.originalUrl;
        logger.warn(`[${selfId}] üîÄ –ü–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª—è–µ–º –Ω–∞ –ª–∏–¥–µ—Ä–∞: ${targetUrl}`);

        const result = await axios({
            method: req.method,
            url: targetUrl,
            data: req.body,
            headers: { ...req.headers, Connection: 'close' },
            validateStatus: () => true
        });

        res.status(result.status).set(result.headers).send(result.data);
    } catch (err) {
        logger.error(`[${selfId}] ‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–∏—Ç—å –Ω–∞ –ª–∏–¥–µ—Ä–∞: ${err.message}`);
        res.status(502).send('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–µ–¥–∏—Ä–µ–∫—Ç–µ –Ω–∞ –ª–∏–¥–µ—Ä–∞');
    }
}

app.post('/key', redirectIfNotLeader, jsonParser, async (req, res) => {
    const { key, value } = req.body;

    logger.info(`[${selfId}] üî• POST /key —Å —Ç–µ–ª–æ–º: ${JSON.stringify(req.body)}`);

    if (!key || value === undefined) {
        logger.warn(`[${selfId}] ‚ùå –ù–µ–ø–æ–ª–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ: key=${key}, value=${value}`);
        return res.status(400).send('‚ùå –ù—É–∂–Ω—ã key –∏ value');
    }

    try {
        await store.saveKeyValue(dataDir, key, value);
        crudStats.create++;
        logger.info(`[${selfId}] ‚úÖ –õ–∏–¥–µ—Ä —Å–æ—Ö—Ä–∞–Ω–∏–ª: ${key}`);

        const nodeId = raft.getNodeId();
        const node = require('../../configuration.json').nodes.find(n => n.id === nodeId);
        const myUrl = `http://localhost:${PORT}`;
        const followers = node.servers.map(s => `http://localhost:${s.port}`).filter(url => url !== myUrl);

        const results = await Promise.allSettled(
            followers.map(url => axios.post(`${url}/internal/replicate`, { key, value }, {
                timeout: 1500,
                headers: { Connection: 'close' }
            }))
        );

        const failed = results.filter(r => r.status !== 'fulfilled');
        if (failed.length > 0) {
            return res.status(207).json({
                resp: {
                    error: {
                        code: 'eREPL01',
                        errno: 207,
                        message: '–ù–µ –≤—Å–µ —Ñ–æ–ª–ª–æ–≤–µ—Ä—ã –ø–æ–¥—Ç–≤–µ—Ä–¥–∏–ª–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ'
                    },
                    data: 0
                }
            });
        }

        res.json({
            resp: {
                error: 0,
                data: {
                    message: '–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ –∏ —Ä–µ–ø–ª–∏—Ü–∏—Ä–æ–≤–∞–Ω–æ',
                    key,
                    node: nodeId
                }
            }
        });
    } catch (err) {
        logger.error(`[${selfId}] ‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏: ${err.message}`);
        res.status(500).json({
            resp: {
                error: {
                    code: 'eSAVE01',
                    errno: 500,
                    message: err.message
                },
                data: 0
            }
        });
    }
});

app.get('/key/:key', async (req, res) => {
    const key = req.params.key;

    try {
        const exists = await store.keyExists(dataDir, key);
        if (!exists) {
            return res.status(404).json({ error: 0, data: '‚ùå –ö–ª—é—á –Ω–µ –Ω–∞–π–¥–µ–Ω' });
        }

        const data = await store.readKeyValue(dataDir, key);
        crudStats.read++;
        if (!data || typeof data !== 'object' || !data.key || !data.value) {
            logger.error(`[${selfId}] ‚ùå –ù–µ–≤–∞–ª–∏–¥–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞ –¥–ª—è –∫–ª—é—á–∞ ${key}`);
            return res.status(500).json({ error: 1, message: '–ù–µ–≤–∞–ª–∏–¥–Ω—ã–π JSON' });
        }

        res.json(data);
    } catch (err) {
        logger.error(`[${selfId}] ‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —á—Ç–µ–Ω–∏–∏ –∫–ª—é—á–∞: ${err.message}`);
        res.status(500).json({ error: 1, message: err.message });
    }
});

app.delete('/key/:key', redirectIfNotLeader, async (req, res) => {
    const key = req.params.key;

    try {
        await store.deleteKeyValue(dataDir, key);
        crudStats.delete++;
        logger.info(`[${selfId}] üóë –£–¥–∞–ª—ë–Ω –ª–æ–∫–∞–ª—å–Ω–æ: ${key}`);

        const nodeId = raft.getNodeId();
        const node = require('../../configuration.json').nodes.find(n => n.id === nodeId);
        const myUrl = `http://localhost:${PORT}`;
        const followers = node.servers.map(s => `http://localhost:${s.port}`).filter(url => url !== myUrl);

        const results = await Promise.allSettled(
            followers.map(url =>
                axios.post(`${url}/internal/delete`, { key }, {
                    timeout: 1500,
                    headers: { Connection: 'close' }
                })
            )
        );

        const failed = results.filter(r => r.status !== 'fulfilled');
        if (failed.length > 0) {
            logger.warn(`[${selfId}] ‚ö†Ô∏è –†–µ–ø–ª–∏–∫–∞—Ü–∏—è —É–¥–∞–ª–µ–Ω–∏—è —á–∞—Å—Ç–∏—á–Ω–æ –Ω–µ —É–¥–∞–ª–∞—Å—å (${failed.length})`);
            return res.status(207).json({
                resp: {
                    error: {
                        code: 'eREPLDEL01',
                        errno: 207,
                        message: '–£–¥–∞–ª–µ–Ω–æ, –Ω–æ –Ω–µ —É –≤—Å–µ—Ö —Ñ–æ–ª–ª–æ–≤–µ—Ä–æ–≤'
                    },
                    data: 0
                }
            });
        }

        res.json({
            resp: {
                error: 0,
                data: {
                    message: '–£–¥–∞–ª–µ–Ω–æ –∏ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞–Ω–æ',
                    key,
                    node: nodeId
                }
            }
        });
    } catch (err) {
        logger.error(`[${selfId}] ‚ùå –û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è: ${err.message}`);
        res.status(500).json({
            resp: {
                error: {
                    code: 'eDEL01',
                    errno: 500,
                    message: err.message
                },
                data: 0
            }
        });
    }
});

app.post('/raft/vote', jsonParser, (req, res) => {
    raft.handleVoteRequest(req, res);
});

app.post('/raft/heartbeat', jsonParser, (req, res) => {
    raft.handleHeartbeat(req, res);
});

app.get('/raft/status', (req, res) => {
    res.json({
        id: raft.id,
        state: raft.state,
        term: raft.currentTerm,
        leader: raft.leaderId
    });
});

app.get('/internal/shutdown', (req, res) => {
    logger.info(`[${selfId}] ‚õî –ü–æ–ª—É—á–µ–Ω —Å–∏–≥–Ω–∞–ª –æ—Å—Ç–∞–Ω–æ–≤–∫–∏`);
    isShuttingDown = true;
    res.send('–û—Å—Ç–∞–Ω–æ–≤–∫–∞ –Ω–∞—á–∞—Ç–∞, –∂–¥—ë–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –æ–ø–µ—Ä–∞—Ü–∏–π...');
});

app.get('/stats', (req, res) => {
    res.json({
        id: selfId,
        stats: crudStats
    });
});


app.listen(PORT, async () => {
    await fs.ensureDir(dataDir);
    logger.info(`[${selfId}] üöÄ Server is running on ${PORT}`);
});
